# -*- coding: utf-8 -*-
"""02_Introducción_a_Pandas_copia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JPingVH7my5C5CZtbVsBEqRClbmK2bcd

## **Introducción a Pandas**
"""

# Instalación de librerías
!pip install pandas

!pip install numpy

# Series: Son estructuras que permiten guardar información de una variable individualmente. Podríamos decir que están representadas por cada columna de una base de datos

import pandas as pd

serie = pd.Series([2,4,6,8,10,12])

serie

serie2 = [2,4,6,8,10,12]

serie2

notas = pd.Series([20,19,20,18,17,16])

notas

notas.value_counts

# DataFrame: Es una estructura tabular que contiene y ordena una colección de Series, donde cada Serie representa una columna
# Primero creamos un diccionario

data_1 = {"estado" : ["SOLTERO","CASADO","VIUDO","SOLTERO"],
          "fecha_nacimiento" : [1992,1994,1990,1989],
          "notas" : [19, 18, 20, 12],
          "edad" : [30, 28, 32, 33]}

data_1

df_1 = pd.DataFrame(data_1)

df_1

df_3 = pd.DataFrame(df_1, columns=["fecha_nacimiento","estado","edad","notas","desempleo"])

df_3

df_3["desempleo"] = 500

df_3

df_3 = df_3.drop(["desempleo"],axis=1)

df_3

df_3*5

df_3.T

"""# **Análisis descriptivo básico**"""

import numpy as np

mi_random = np.random.RandomState()

mi_random

datos = mi_random.normal(1000,550,size=(36,4))

datos

inventario = pd.DataFrame(datos,columns=["ProductoA","ProductoB","ProductoC","ProductoD"]).astype(int)

inventario.head()

fechas = pd.date_range(end="Apr-2020",periods=len(inventario),freq="1M")

fechas

inventario["Fecha"] = fechas

inventario.head()

inventario.head(7)

inventario.tail(9)

inventario.sample(6)

inventario.describe()

inventario.describe(percentiles=[0.01,0.10,0.20,0.25,0.50,0.75,0.90,0.99])

inventario.describe(percentiles=[0.01,0.10,0.20,0.25,0.50,0.75,0.90,0.99]).T

inventario.set_index("Fecha", inplace=True)

inventario.head(6)

inventario[("2019" > inventario.index)]

# Que quiero ver como cerró el 2019 (dic-19)

inventario.loc['2019-12']

# Supongamos que queremos revisar cuando nuestro inventario en el producto A ha sido menor a 200

inventario[inventario["ProductoA"]<200]

inventario[inventario["ProductoA"]>200]

# Filtro que me ubique todas las filas con un valor (por lo menos) menor a 200

inventario.query("ProductoA<200 or ProductoB<200 or ProductoC<200 or ProductoD<200")

"""## **Rankeo y ordenamiento de filas**"""

# Necesito una columna totalizadora mensual de los inventarios

inventario["Total"] = inventario.sum(axis=1)

inventario.head()

# Quiero ordenar mi base de menor a mayor según la columna total

inventario.sort_values(by="Total").head(5)

# Quiero visualizar los 7 meses con mayor cantidad total de productos, ordenados de mayor a menor

inventario.sort_values(by="Total",ascending=False).head(7)

# Función que me retorna el mes a partir de la fecha

def mes_de_fecha(fecha):
    return fecha.month

# Función que me retorne el año a partir de una fecha

def ano_de_fecha(fecha):
    return fecha.year

# Para aplicar la función que he creado necesito que la columna fecha no esté indexada

inventario.reset_index("Fecha", inplace=True)

inventario.head()

inventario["Mes"] = inventario["Fecha"].apply(mes_de_fecha)

inventario.head()

inventario["Año"] = inventario["Fecha"].apply(ano_de_fecha)

inventario.sample()

inventario.set_index(["Fecha"],inplace=True)

inventario.head()

"""## **Función groupby**"""

# Queremos saber el stock inventario promedio por año según producto y total

inventario.groupby("Año").mean()

inventario.groupby("Mes").mean()

# Mi objetivo es mostrar la volatilidad o dispersion por mes

inventario.groupby("Mes").std()

# Supongamos que necesitamos saber los promedios y las dispersiones de productos B y C anuales

inventario.groupby("Año").aggregate({"ProductoB":[np.mean,np.std],"ProductoC":[np.mean,np.std]})

# Ahora para el producto A solamente

inventario.groupby("Año").aggregate({"ProductoA":[np.mean,np.std]})

inventario.groupby("Año").aggregate({"ProductoB":[np.mean,np.std],"ProductoC":[np.median,np.std]})

# Y si ahora queremos las mismas métricas para todas las columnas de tu base

inventario.groupby("Año").aggregate([np.median,np.std])

"""# **Función pivot_table**"""

inventario.pivot_table(index="Año", aggfunc=[np.mean,np.std])



