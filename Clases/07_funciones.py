# -*- coding: utf-8 -*-
"""07_Funciones.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/163jHAKZgbyf4oTHis6PPuvnlbNpMAAC_

#  Introducción a las Funciones

Una función es un conjunto de expresiones y sentencias (algoritmo) que se ejecuta cuando es invocada

def funcion_1():
    # aquí el algoritmo, si no se va a poner nada usar pass

Para ejecutar una función, es necesario que sea invocada
"""

def funcion_1():
    print("Hola Mundo")
    # return(None)  implícitamente no devuelve nada

funcion_1()

"""
Cuando una función, haga un retorno de datos, éstos, pueden ser asignados a una variable:"""

def funcion_2():
    return("Hola Mundo")

frase = funcion_2()
print(frase)

"""Otro ejemplo:"""

def multiplica_por_5(numero):
    print(f'{numero} * 5 = {numero * 5}')
# muestra un mensaje personalizado, esto se llama cadenas f
# este el fin delprograma

print('Comienzo del programa')
multiplica_por_5(7)
print('Siguiente')
multiplica_por_5(113)
print('Fin')

"""#### Varios return en una misma función
return hace que termine la ejecución de la función cuando aparece y el programa continúa por su flujo normal.
"""

def es_par(numero):
    if numero % 2 == 0:
        return True
    else:
        return False

print(es_par(2))
print(es_par(3))

"""#### Devolver más de un valor con return en Python"""

def cuadrado_y_cubo(numero):
    return numero ** 2, numero ** 3, numero

cuad, cubo, num = cuadrado_y_cubo(5)  # desempaquetado de funciones
print(cuad)
print(cubo)
print(num)

"""#### Parámetros por omisión

Se puede asignar parámetros por defecto, esto permite que la función pueda ser invocada con menos parámetros
"""

def saludo(nombre, mensaje='Hola'):
    print(mensaje, nombre)

saludo('Luis Garayar')

saludo('Luis Garayar',"Buenas noches")

saludo()

"""Se tiene que declarar los argumentos con valores por defecto (opcionales) siempre después de los argumentos obligatorios."""

def saludo(nombre='Luis Garayar', mensaje):
    print(mensaje, nombre)

"""<br>Creamos una función `add_numbers` para que tome dos números y los sume:"""

def add_numbers(x, y):
    return x + y

add_numbers(1, 2)

"""<br> Actualizamos `add_numbers` para tomar un tercer parámetro opcional. El uso de `print` permite imprimir múltiples expresiones dentro de una sola ejecución:"""

def add_numbers(x,y,z=None):
    if (z==None):
        return x+y
    else:
        return x+y+z

print(add_numbers(1, 2))
print(add_numbers(1, 2, 3))

"""<br> Actualizamos `add_numbers` para tomar un parámetro flag opcional:"""

def add_numbers(x, y, z=None, flag=False):
    if (flag):
        print('Flag is true!')
    if (z==None):
        return x + y
    else:
        return x + y + z

print(add_numbers(1, 2, flag=True))

"""<br>Asignar la función `add_numbers` a la variable `a`:"""

def add_numbers(x,y):
    return x+y

a = add_numbers   #"cambio de nombre de una función"
a(1,2)

a = add_numbers         # asignando la función a la variable a
print(a)
print(type(a))
a = add_numbers(1,2)    # asignando el resultado de la función a la variable a

"""
Ejemplo: Crear una función que sume los N primeros números naturales
"""

def suma_n(n):
    suma = 0
    for i in range(n+1):
        suma = suma + i
    return(suma)

s = suma_n(100000)
print(s)

"""¿Que hace la siguiente función?"""

def transforma_numero(numero):
    if (numero%2 == 0):
        return(numero*2)
    else:
        return(numero*3)

print(transforma_numero(15))
print(transforma_numero(16))

"""## Funciones integradas

El interprete Python tiene un número de funciones integradas (built-in), las cuales están siempre disponibles. Tenemos algunas funciones que ya hemos usado:

abs()    # devuelve el valor absoluto de un número (entero o de coma flotante)
dict()   # permite crear un diccionario
float()  # devuelve un número coma flotante float
help()   # invoca el menú de ayuda del intérprete de Python
int()    # devuelve un número entero
input()  # lee una cadena de caracteres desde la entrada estándar
len()    # devuelve el número de elementos de un tipo de secuencia o colección
list()   # permite crear una lista mutable
long()   # devuelve un número entero largo
max()    # si recibe más de un argumento, devuelve el mayor de ellos
min()    # si recibe más de un argumento, devuelve el menor de ellos
pow()    # recibe dos argumentos, eleva el primero argumento a la potencia del segundo
print()  # permite imprimir en consola
range()  # devuelve una lista conteniendo una progresión aritmética de enteros
round()  # redondea un número flotante a una precisión dada en dígitos decimal
set()    # crea un conjunto mutable, tambipen existe frozenset()
str()    # se usa crear una carácter o cadenas de caracteres
sum()    # devuelve la suma de una lista o de una secuencia
tuple()  # permite crear una tupla, que es una lista inmutable
type()   # devuelve el tipo del objeto que recibe como argumento

Veamos algunas funciones adicionales que pueden ser de utilidad:
"""

# eval(): Evalúa una cadena como una expresión
eval('2 + 5')

# abs(): Devuelve el valor absoluto de un número (entero o de coma flotante)
abs(-10)

# sorted(): devuelve una lista ordenada de los elementos que recibe (lista o cadena de caracteres)
lista = [23, 13, 7, 37]
print(sorted(lista))
cadena = "murcielago"
print(sorted(cadena))

# zip(): devuelve una lista de tuplas, donde cada una contiene el elemento iésimo desde cada secuencia de argumento
list(zip(['python', 'zope', 'plone'], [2.7, 2.13, 5.1]))

paises = ["China", "India", "Estados Unidos", "Indonesia"]
poblaciones = [1391, 1364, 327, 264]
list(zip(paises, poblaciones))

# split(): devuelve una lista con la cadena de caracteres separada por cada indice de la lista
cad = 'leonardo caballero'
cad.split()   # por defecto usa el espacio como separador

cad.split('o')

# swapcase(): devuelve una cadenas de caracteres convertida al opuesto sea MAYÚSCULAS o MINÚSCULAS
cad2 = 'Luis Garayar'
cad2.swapcase()

# title(): devuelve una cadenas de caracteres con capitales en cada palabra
cad2 = 'programa de televisión'
cad2.title()

# iter(): obtiene un iterador de un objeto
# next(): devuelve el próximo elemento desde un iterador
elemento = iter([1,2,3,4,5])
print(next(elemento))
print(next(elemento))
print(next(elemento))
print(next(elemento))
print(next(elemento))

elemento2 = iter("Plano")
print(next(elemento2))
print(next(elemento2))
print(next(elemento2))
print(next(elemento2))
print(next(elemento2))

# map(): ejecuta una función sobre cada elemento de un iterador (generalmente una lista o tupla)
def dup(n):
    return n * 2

list(map(dup, [1, 2, 3, 4]))

def mult(a, b):
    return a * b

list(map(mult, [1, 2, 3, 4], [5, 6, 7, 8]))

"""**Sigamos con un ejemplo:** Diseñar una función que, ante una petición de dinero, muestre por pantalla los billetes y monedad de cada tipo que se entregarán:"""

def sacar_dinero(cantidad):
    de100 = cantidad//100
    cantidad = cantidad%100
    de50 = cantidad//50
    cantidad = cantidad%50
    de20 = cantidad//20
    cantidad = cantidad%20
    de10 = cantidad//10
    cantidad = cantidad%10
    de5 = cantidad//5
    cantidad = cantidad%5
    de2 = cantidad//2
    de1 = cantidad%2
    print("Billetes y monedas de:")
    print("100 50 20 10  5  2  1")
    print([de100,de50,de20,de10,de5,de2,de1])

sacar_dinero(8588)

sacar_dinero(950)

def sacar_dinero2(cantidad):
    denominacion = [100,50,20,10,5,2]
    for monto in denominacion:
        print("Billetes de "+ str(monto) +": "+ str(cantidad//monto))
        cantidad = cantidad%monto
    print("Billetes de 1: "+ str(cantidad))

sacar_dinero2(8588)

sacar_dinero2(950)

"""## Funciones recursivas

Se denomina llamada recursiva (o recursividad), a aquellas funciones que en su algoritmo, hacen referencia sí misma.

Las llamadas recursivas suelen ser muy útiles en casos muy puntuales, pero debido a su gran factibilidad de caer en iteraciones infinitas, deben extremarse las medidas preventivas adecuadas y, solo utilizarse cuando sea estrictamente necesario y no exista una forma alternativa viable, que resuelva el problema evitando la recursividad.
"""

def jugar(intento=1):
    respuesta = input("¿De qué color es una naranja? ")
    if respuesta != "naranja":
        if intento < 3:
            print("\nFallaste! Inténtalo de nuevo")
            intento = intento + 1
            jugar(intento) # <-------------------- Llamada recursiva
        else:
            print("\nPerdiste!")
    else:
        print("\nGanaste!")

jugar()

"""### Función recursiva sin retorno"""

def cuenta_regresiva(numero):
    numero = numero - 1
    if numero > 0:
        print(numero)
        cuenta_regresiva(numero)
    else:
        print("Boooooooom!")
    print("Fin de la función " + str(numero))

cuenta_regresiva(10)

"""### Función recursiva con retorno

**Ejemplo 1:** Crear una función recursiva para el calculo del factorial de un número:
"""

def factorial_recursivo(numero):
    if numero > 1:
        numero = numero * factorial_recursivo(numero -1)
    print("valor final -> " + str(numero))
    return numero

print(factorial_recursivo(5))

print(factorial_recursivo(500))

"""**Ejemplo 2:** Crear una función que sume los N primeros números naturales de forma recursiva:"""

def suma_n(numero):
    if numero > 0:
        numero = numero + suma_n(numero -1)
    print("valor final -> " + str(numero))
    return numero

print(suma_n(5))

"""## Parámetros arbitrarios

Los parámetros arbitrarios se utilizan cuando la función recibirá un número arbitrario (desconocido) de parámetros. Para definir argumentos arbitrarios en una función, se antecede al parámetro un asterisco (*):
"""

def recorrer_parametros_arbitrarios(parametro_fijo, *arbitrarios):
    print(parametro_fijo, " ---fijo")

    # Los parámetros arbitrarios se corren como tuplas
    for argumento in arbitrarios:
        print(argumento, " ---arbitrario")

recorrer_parametros_arbitrarios('Fixed', 'arbitrario 1', 'arbitrario 2', 'arbitrario 3')

recorrer_parametros_arbitrarios('Fixed', 'arbitrario 1', 'arbitrario 2', 'arbitrario 3', 'arbitrario 4', 'arbitrario 5', 'arbitrario 6')

"""**Ejemplo:** Una función que sume todos los números ingresados como parámetros"""

def suma_arbitraria (a = 0, *args):
    print(a)
    for i in args:
        a = a + i
        print(a)

suma_arbitraria()

suma_arbitraria(5)

suma_arbitraria(5,8)

suma_arbitraria(5,8,13,4,5,7,8,10,14)

"""Es posible también, obtener parámetros arbitrarios como pares de clave=valor. En estos casos, al nombre del parámetro deben precederlo dos astericos (**)"""

def recorrer_parametros_arbitrarios(parametro_fijo, *arbitrarios, **kwords):
    print(parametro_fijo, " ---fijo")
    for argumento in arbitrarios:
        print(argumento, " ---arbitrario")

    # Los argumentos arbitrarios tipo clave, se recorren como los diccionarios
    for clave in kwords:
        print("El valor de", clave, "es", kwords[clave], " ---kword")

recorrer_parametros_arbitrarios("Fixed", "arbitrario 1", "arbitrario 2", "arbitrario 3", clave1="valor uno", clave2="valor dos")

def otra_func(**kwargs):
    if kwargs is not None:
        for key in kwargs:
            print("%s ==> %s" %(key,kwargs[key]))   # una forma de imprimir valores de un diccionario

otra_func(nombre = "Luis", apellido = "Garayar", apellido2 = "Burneo", perro = "Fido")

"""### Desempaquetado de parámetros

Puede ocurrir además, una situación inversa a la anterior. Es decir, que la función espere una lista fija de parámetros, pero que éstos, en vez de estar disponibles de forma separada, se encuentren contenidos en una lista o tupla. En este caso, el signo asterisco (*) deberá preceder al nombre de la lista o tupla que es pasada como parámetro durante la llamada a la función:
"""

def calcular(importe, descuento):
    return importe - (importe * descuento / 100)

print(calcular(2000,20))

datos = [1500, 10]
print(calcular(*datos))   # desempaqueta valores de una lista o tupla

"""El mismo caso puede darse cuando los valores a ser pasados como parámetros a una función, se encuentren disponibles en un diccionario. Aquí, deberán pasarse a la función, precedidos de dos asteriscos (**):"""

datos = {"descuento": 10, "importe": 1500}
print(calcular(**datos))  # desempaqueta valors de un diccionario

"""## Funciones lambda

Las funciones ***lambda*** son funciones de una sola expresión:
"""

potencia = lambda x,y: x**y
potencia(19,3)

potencia(2,5)

list(map(lambda x: x**2,[1,2,3,25,33]))

revertir = lambda cadena: cadena[::-1]
revertir("PERCYTECH")

impar = lambda numero: numero%2 != 0
impar(5)

impar(2)

"""Aquí hay un ejemplo de `lambda` que toma tres parámetros y agrega los dos primeros:"""

my_function = lambda a, b, c : a + b

my_function(1, 2, 3)

my_function(1, 2, "Hola")

"""## Comprensión de listas

Consiste en construir listas a partir de otras listas, usando condicionales y bucles. Muy útiles para reemplazar bucles simples.
"""

[x ** 2 for x in [1,2,3,25,33]]   #más simple que usar list, map y lambda

"""Vamos a iterar de 0 a 999 y devolver los números pares"""

my_list = []
for number in range(0, 1000):
    if number % 2 == 0:
        my_list.append(number)
print(my_list)

"""Ahora lo mismo pero con comprensión de la lista:"""

my_list = [number for number in range(0,1000) if number % 2 == 0]
print(my_list)

"""## Manejo de Excepciones en funciones"""

1/0

'a'/5

"""Para el manejo de excepciones se utiliza una estructura de control especial **try-except-finally**

* Si ocurre una excepción en el bloque **try** se pasa directamente a evaluar el tipo en el(los) bloque(s) **except**.
* Si la excepción no coincide con la excepción nombrada en el(los) except(s) se trata de una excepción no manejada.
* El bloque **finally** siempre se ejecuta en cualquier caso.
"""

def dividir(x, y):
    try:
        resultado = x / y
    except ZeroDivisionError:
        print("¡división por cero!")
    except TypeError:
        print("¡numerador o denominador no son numeros!")
    else:
        print("el resultado es " + str(resultado))
    finally:
        print("ejecutando la clausula finally")

dividir(10, 5)

dividir(10, 0)

dividir("a", 5)

dividir(5, 'b')

"""Realiza una función que reciba una lista y un elemento. La función debe añadir el elemento al final de la lista con la condición de no repetir ningún elemento. Además si este elemento ya se encuentra en la lista se debe invocar un error de tipo ValueError que debes capturar y mostrar este mensaje en su lugar:


"""

elementos = [1, 5, -2]

# Completa el ejercicio aquí
def agregar_una_vez(lista, el):
    try:
        if el in lista:
            raise ValueError    # es un generador de errores
        else:
            lista.append(el)
            print(lista)
    except ValueError:
        print("Error: Imposible añadir elementos duplicados =>", el)

print(agregar_una_vez(elementos, 10))

print(agregar_una_vez(elementos, -2))

print(agregar_una_vez(elementos, "Hola"))

print(elementos)

"""La sentencia **raise** permite al programador forzar a que ocurra una excepción específica. Por ejemplo:"""

raise NameError('Hola')

try:
    raise NameError('Hola')
except NameError:
    print('Ha sucedido una excepción!')
    raise

"""Más información sobre errorres y excepciones en
* https://docs.python.org/es/3/tutorial/errors.html
* https://entrenamiento-python-basico.readthedocs.io/es/latest/leccion9/errores.html

## Llamando a un módulo implementado
"""

import modulo_funciones as mf   #forma clásica, llama a todas las funciones

help(mf)

help(mf.es_par)

dir(mf)

mf.es_par(156)

mf.sumar_numeros(30,15,6)

from modulo_funciones import es_par  # llamando una función específica

numero = int(input("Ingrese n°: "))
if es_par(numero):
    print("Número par")
else:
    print("Número impar")

from modulo_funciones import sumar_numeros as nueva_suma # llamando una función específica con otro nombre

nueva_suma(15,35)

from modulo_funciones import sumar_numeros, es_par # llamando más de una función específica

print(sumar_numeros(90,25))
print(es_par(73))

# no es recomendable usarlo porque deja sueltas las funciones de una librería
from modulo_funciones import *
print(es_par(73))

# mejor utilizar la importación clásica ---> import modulo_funciones as mf ---> mf.funcion

"""Otro ejemplo:"""

from areas import cuadrado

help(cuadrado)

import areas
help(areas)

print(areas.pi)

print(areas.cuadrado(3))

print(areas.circulo(5))

"""***Recomendación: Practicar agregando nuevas funciones al módulo "areas.py"***"""