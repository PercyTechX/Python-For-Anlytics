# -*- coding: utf-8 -*-
"""08_Clases y Objetos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UYMKzsn8kHTkI28VKt6Fh_FqT2d5MxHD

# Programación Orientada a Objetos

## Clases

Las clases son los modelos sobre los cuáles se construirán nuestros objetos
"""

class Auto:
    pass

class Llanta:
    pass

class Espejo:
    pass

class Timon:
    pass

"""La sentencia pass no hace nada. Puede ser utilizada cuando se requiere una sentencia sintácticamente pero programa no requiere acción alguna.

El nombre de las clases se define en singular, utilizando CamelCase.

## Propiedades (o atributos)

Las propiedades, como hemos visto antes, son las características intrínsecas del objeto
"""

class Llanta():
    color = ""
    forma = ""

class Espejo():
    tamanio = ""
    color = ""

class Timon():
    forma = ""
    color = ""

class Auto():
    color = ""
    tamanio = ""
    aspecto = ""
    llantas = Llanta()    # propiedad compuesta por el objeto objeto Llanta
    espejos = Espejo()    # propiedad compuesta por el objeto objeto Espejo
    timones = Timon()     # propiedad compuesta por el objeto objeto Timon

"""Las propiedades se definen de la misma forma que las variables (aplican las mismas reglas de estilo).

## Métodos (o funciones)

Los métodos son funciones que representan acciones propias que puede realizar el objeto (y no otro)
"""

class Auto():
    color = "rojo"
    tamanio = "grande"
    aspecto = "bonito"
    llantas = Llanta()
    espejos = Espejo()
    timones = Timon()

    def arrancar(self):
        pass

    def comparar(self,otroAuto):
        pass

"""Notar que el primer parámetro de un método, siempre debe ser self.

## Objeto

Las clases por sí mismas, no son más que modelos que nos servirán para crear objetos en concreto. Podemos decir que una clase, es el razonamiento abstracto de un objeto, mientras que el objeto, es su materialización. A la acción de crear objetos, se la denomina instanciar una clase y dicha instancia, consiste en asignar la clase, como valor a una variable:
"""

class Auto():
    color = "rojo"
    tamanio = "grande"
    aspecto = "bonito"
    llantas = Llanta()
    espejos = Espejo()
    timones = Timon()

    def arrancar(self):
        print("auto encendido")

auto_1 = Auto()
print(auto_1.color)
print(auto_1.tamanio)
print(auto_1.aspecto)
auto_1.color = "amarillo"
print(auto_1.color)
auto_1.arrancar()

"""## Herencia: característica principal de la POO

Algunos objetos comparten las mismas propiedades y métodos que otro objeto, y además agregan nuevas propiedades y métodos. A esto se lo denomina herencia: una clase que hereda de otra.
"""

class Llanta():
    color = ""
    forma = ""

class Espejo():
    tamanio = ""
    color = ""

class Timon():
    forma = ""
    color = ""

class Auto():
    color = "rojo"
    tamanio = "grande"
    aspecto = "bonito"
    llantas = Llanta()
    espejos = Espejo()
    timones = Timon()

    def arrancar(self):
        print("auto encendido")

class Letrero():
    color = ""
    forma = ""

# Taxi sí hereda de otra clase: Auto
class Taxi(Auto):
    letreros = Letrero()

    def hacer_taxi(self):
        print("iniciando taxi")

"""### Accediendo a los métodos y propiedades de un objeto

Una vez creado un objeto, es decir, una vez hecha la instancia de clase, es posible acceder a su métodos y propiedades
"""

taxi_1 = Taxi()
print(taxi_1.color)
print(taxi_1.tamanio)
print(taxi_1.aspecto)
taxi_1.color = "amarillo"
print(taxi_1.color)
arrancar = taxi_1.arrancar()
arrancar
taxi_1.hacer_taxi()

"""### Otro ejemplo de herencia:

En la sección anterior, hemos inicializado color y forma, dándoles un valor vacío ''. Pero hay una forma más elegante de inicializar variables con sus valores predeterminados. El inicializador es un método especial, con nombre __init__ (el método se considera especial y será tratado de forma especial, es por eso que tiene subrayados dobles al principio y al final).
"""

class Figura:
    def __init__(self, a):
        self.name = a

forma = Figura()

forma = Figura('figura1')

"""Los métodos son como funciones, necesitan tener un argumento convenientemente llamado **self**, que se refiere al objeto del método que está siendo llamado. Date cuenta que en una llamada al método, no necesitamos pasar self como un argumento, Python se encargará de eso por nosotros. Si no ponemos self como argumento, Python arrojará un error."""

#Definición de clases en python
class Rectangulo(Figura):
    def __init__(self,x,y, a): # constructor
        self.x = x #creación de parámetros internos
        self.y = y
        Figura.__init__(self,a)

    autor = "anonimo" # creación de parámetros de forma externa al constructor
    descripcion="esto es un rectangulo"

    def area(self):
        return self.x*self.y

    def perimetro(self):
        return 2*self.x*self.y

    def cambio_descripcion(self,text):
        self.descripcion=text

# si modificamos la clase, tenemos que volver a instanciar los objetos creados
# para que reciban los cambios

rectangulo1 = Rectangulo(90,35,1)
rectangulo2 = Rectangulo(20,11,2)
print(rectangulo1.area())

print(rectangulo1.descripcion)
rectangulo1.cambio_descripcion("Rectangulo de juguete")
print(rectangulo1.descripcion)

print(rectangulo2.area())

print(rectangulo1.name)
print(rectangulo2.name)

"""### Miembros privados
Python no tiene miembros privados, pero existe una convención para tratar como privados los miembros que empiezan por _
"""

class Rectangulo2:
    def __init__(self,x,y): # constructor
        self.x = x #creación de parámetros internos
        self.y = y

    _autor = "anonimo" # creación de parámetros de forma externa al constructor y privado
    _descripcion="esto es un rectangulo"

    def area(self):
        return self.x*self.y

    def perimetro(self):
        return 2*self.x*self.y

    def descripcion(self,text):
        self._descripcion=text

    def _privateMethod(self):
        print('Este método debería no llamarse desde fuera')

rec = Rectangulo2(1,2)
rec._privateMethod()

dir(rec)

rec.area()

rec.perimetro()

"""### Un ejemplo más:

Vamos a ver el comportamiento de los "métodos mágicos"
"""

def mcd(m,n):
    while m%n != 0:
        mViejo = m
        nViejo = n

        m = nViejo
        n = mViejo%nViejo
    return n

mcd(5,3)

mcd(5,25)

mcd(18,9)

class Fraccion:
    def __init__(self,arriba,abajo):
        self.num = arriba
        self.den = abajo

    def __str__(self):
        return str(self.num)+"/"+str(self.den)    # __str__ permite que print funcione sobre los objetos

    def show(self):
        print(self.num,"/",self.den)

    def __add__(self,otraFraccion):              # define el comportamiento del operador +
        nuevoNum = self.num*otraFraccion.den + \
                    self.den*otraFraccion.num
        nuevoDen = self.den * otraFraccion.den
        comun = mcd(nuevoNum,nuevoDen)
        return Fraccion(nuevoNum//comun,nuevoDen//comun)

    # otros métodos de operaciones se pueden realizar para la substracción (__sub__)
    # para la multiplicación (__mul__) y división (__truediv__)

    # implementación de métodos "mágicos" que permiten hacer comparaciones
    def __eq__(self, otro):                     # define el comportamiento de la igualdad (==)
        primerNum = self.num * otro.den
        segundoNum = otro.num * self.den
        return primerNum == segundoNum
    def __gt__(self, otro):                  # define el comportamiento del mayor que (>)
        primerNum = self.num * otro.den
        segundoNum = otro.num * self.den
        return primerNum > segundoNum
    def __ge__(self, otro):                 # define el comportamiento del mayor o igual que (>=)
        primerNum = self.num * otro.den
        segundoNum = otro.num * self.den
        return primerNum >= segundoNum

x = Fraccion(1,2)
y = Fraccion(2,4)

x.show()
y.show()

print(x)

print(x+y)  # conoca al metoro __add__

print(x == y)   # convoca al metodo __eq__
print(x > y)    # convoca al metodo __gt__

print(x < y)   # crea su contraparte __lt__

print(x >= y)  # convoca al método __ge__

print(x <= y) # convoca al método __le__

"""Ejemplo con otras fracciones:"""

x = Fraccion(1,3)
y = Fraccion(1,2)

x.show()
y.show()

print(x+y)  # conoca al metoro __add__

print(x == y)   # convoca al metodo __eq__
print(x > y)    # convoca al metodo __gt__

print(x < y)

print(x >= y)

"""#### Otro ejemplo:"""

class Ejemplo:
    __atributo_privado = "Soy un atributo inalcanzable desde fuera."

    def __metodo_privado(self):
        print("Soy un método inalcanzable desde fuera.")

    def atributo_publico(self):
        return self.__atributo_privado

    def metodo_publico(self):
        return self.__metodo_privado()

e = Ejemplo()
print(e.atributo_publico())
e.metodo_publico()

"""#### Ejemplo 2:

Implementemos la clase Punto:
"""

class Punto():
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def __add__(self,p):
        x2 = self.x + p.x
        y2 = self.y + p.y
        z = Punto(x2,y2)
        return z

    def __str__(self):
        return "("+str(self.x)+","+str(self.y)+")"

    def distancia(self,otro):
        x_new = pow(self.x - otro.x,2)
        y_new = pow(self.y - otro.y,2)
        dist = pow(x_new+y_new,1/2)
        return dist

    #crear la clase módulo y suma de puntos

punto1 = Punto(1,1)
punto2 = Punto(2,2)

print(punto1)

print(punto1+punto2)

punto1.distancia(punto2)

"""### Getter y Setter"""

class Alumno:

  def __init__(self, nombre, codigo, correo):
    self.nombre = nombre
    self.codigo = codigo
    self.correo = correo

  #Método para consultar el valor de un atributo en particular

  def getCorreo(self):
    return self.correo

  #Método para actualizar el valor de un atributo en particular

  def setCorreo(self, nuevo_correo):
    self.correo = nuevo_correo

a1 = Alumno('jair', '01', 'jair@gmail.com')

a1.correo

a1.getCorreo()

a1.setCorreo('loayza@gmail.com')

a1.getCorreo()

"""#### Ejemplo 3:

Un ejemplo sobre un **catálogo de películas:**
"""

class Pelicula:

    # Constructor de clase
    def __init__(self, titulo, duracion, lanzamiento):
        self.titulo = titulo
        self.duracion = duracion
        self.lanzamiento = lanzamiento
        print('Se ha creado la película:', self.titulo)

    def __str__(self):
        return '{} ({})'.format(self.titulo, self.lanzamiento)


class Catalogo:

    peliculas = []  # Esta lista contendrá objetos de la clase Pelicula

    def __init__(self, peliculas=[]):
        self.peliculas = peliculas

    def agregar(self, p):  # p será un objeto Pelicula
        self.peliculas.append(p)

    def mostrar(self):
        for p in self.peliculas:
            print(p)  # Print toma por defecto str(p)

p = Pelicula("El Padrino", 175, 1972)
print(p)

c = Catalogo([p])  # Añado una lista con una película desde el principio
c.mostrar()
c.agregar(Pelicula("El Padrino: Parte 2", 202, 1974))  # Añadimos otra
c.mostrar()

"""#### Ejemplo 4:

Listado de clientes en una empresa:
"""

clientes= [
    {'Nombre': 'Hector', 'Apellidos':'Costa Guzman', 'dni':'11111111A'},
    {'Nombre': 'Juan', 'Apellidos':'González Márquez', 'dni':'22222222B'},
    {'Nombre': 'Rosa', 'Apellidos':'Perez Quispe', 'dni':'33333333C'}
]

# Creo una estructura para los clientes
class Cliente:

    def __init__(self, dni, nombre, apellidos):
        self.dni = dni
        self.nombre = nombre
        self.apellidos = apellidos

    def __str__(self):
        return '{} {}'.format(self.nombre,self.apellidos)

# Y otra para las empresas
class Empresa:

    def __init__(self, clientes=[]):
        self.clientes = clientes

    def mostrar_cliente(self, dni=None):
        for c in self.clientes:
            if c.dni == dni:
                print(c)
                return
        print("Cliente no encontrado")

    def borrar_cliente(self, dni=None):
        for i,c in enumerate(self.clientes):
            if c.dni == dni:
                del(self.clientes[i])
                print(str(c),"> BORRADO")
                return
        print("Cliente no encontrado")

# Creo un par de clientes
hector = Cliente(nombre="Hector", apellidos="Costa Guzman", dni="11111111A")
juan = Cliente("22222222B", "Juan", "Gonzalez Marquez")
rosa = Cliente("33333333C", "Rosa", "Perez Quispe")

# Creo una empresa con los clientes iniciales
empresa = Empresa(clientes=[hector, juan, rosa])

# Muestro todos los clientes
print("==CANTIDAD DE CLIENTES==")
len(empresa.clientes)

print("\n==MOSTRAR CLIENTES POR DNI==")
# Consulto clientes por DNI
empresa.mostrar_cliente("11111111A")
empresa.mostrar_cliente("11111111Z")

print("\n==BORRAR CLIENTES POR DNI==")
# Borro un cliente por DNI
empresa.borrar_cliente("22222222V")
empresa.borrar_cliente("22222222B")

# Muestro de nuevo todos los clientes
print("\n==CANTIDAD DE CLIENTES==")
len(empresa.clientes)